// Generated by CoffeeScript 1.9.3
var DATE_ARGS_FORMAT, DAY_ARGS_FORMAT, INVALID_ARGS_FORMAT, TIME_ARGS_FORMAT, UNKNOWN_OPERATOR_ERROR, UNKNOWN_PARAMETER_ERROR, UNKNOWN_TYPE_ERROR, _, evaluate, moment, parseAndEvaluate, parser, recursive_evaluate, restrictions, strToMomentDate, util;

_ = require("lodash");

util = require("util");

moment = require("moment");

parser = require('./ruleParser');

UNKNOWN_OPERATOR_ERROR = "Evaluation Error: Unknown operator '%s'.";

UNKNOWN_TYPE_ERROR = "Evaluation Error: A node of an unknown type '%s' was found.";

UNKNOWN_PARAMETER_ERROR = "Evaluation Error: The parameter '%s' is not supported.";

INVALID_ARGS_FORMAT = "Evaluation Error: Invalid arguments format. Expected format was %s";

TIME_ARGS_FORMAT = "'hh:mm - hh:mm'";

DATE_ARGS_FORMAT = "'[month/]day[/year][-[month/]day[/year]]'; a) Year must have 4 digits. b) You can use 'null' instad of a date to specify indefiniteness.";

DAY_ARGS_FORMAT = "'week_day[, another_week_day[, ...]]'";

restrictions = {
  time: function(value) {
    var fromTime, now, ref, result, toTime;
    if (!value.match(/^\s*\d{1,2}\s*:\s*\d{1,2}\s*-\s*\d{1,2}\s*:\s*\d{1,2}\s*$/)) {
      throw new Error(util.format(INVALID_ARGS_FORMAT, TIME_ARGS_FORMAT));
    }
    ref = value.split("-"), fromTime = ref[0], toTime = ref[1];
    fromTime = moment(fromTime, "h:m");
    toTime = moment(toTime, "h:m");
    now = moment();
    result = (fromTime.isBefore(now)) && (now.isBefore(toTime));
    return result;
  },
  day: function(value) {
    var days;
    if (!value.match(/^\s*\w+(?:\s*,\s*\w+)*\s*$/)) {
      throw new Error(util.format(INVALID_ARGS_FORMAT, DAY_ARGS_FORMAT));
    }
    days = value.split(",");
    days = _.map(days, function(str) {
      return str.toString().trim().substring(0, 3).toLowerCase();
    });
    return _.includes(days, moment().format("ddd").toLowerCase());
  },
  date: function(value) {
    var fromDate, now, ref, toDate;
    if (!value.match(/^\s*(?:\d{1,2}(?:\s*\/\s*\d{1,2}(?:\s*\/\s*\d{1,4})?)?|null)(?:\s*-\s*(?:\d{1,2}(?:\s*\/\s*\d{1,2}(?:\s*\/\s*\d{1,4})?)?|null))?\s*$/)) {
      throw new Error(util.format(INVALID_ARGS_FORMAT, DATE_ARGS_FORMAT));
    }
    ref = value.split("-"), fromDate = ref[0], toDate = ref[1];
    if (toDate == null) {
      toDate = fromDate;
    }
    if (fromDate === "null") {
      fromDate = "01/01";
    }
    if (toDate === "null") {
      toDate = "12/31";
    }
    fromDate = strToMomentDate(fromDate);
    toDate = strToMomentDate(toDate);
    now = moment();
    return fromDate.isValid() && (fromDate.isBefore(now)) && toDate.isValid() && (now.isBefore(toDate.add(1, 'd')));
  }
};

strToMomentDate = function(str) {
  switch ((str.match(/\//g) || []).length) {
    case 0:
      return moment(str, "DD");
    case 1:
      return moment(str, "MM-DD");
    case 2:
      return moment(str, "MM-DD-YYYY");
  }
};

recursive_evaluate = function(condition) {
  if (condition.type === "BinaryExpression") {
    if (condition.operator === "|") {
      return (recursive_evaluate(condition.left)) || (recursive_evaluate(condition.right));
    } else if (condition.operator === "&") {
      return (recursive_evaluate(condition.left)) && (recursive_evaluate(condition.right));
    } else {
      throw new Error(util.format(UNKNOWN_OPERATOR_ERROR, condition.operator));
    }
  } else if (condition.type === "Restriction") {
    if (restrictions[condition.param] != null) {
      return restrictions[condition.param](condition.value);
    } else {
      throw new Error(util.format(UNKNOWN_PARAMETER_ERROR, condition.param));
    }
  } else if (condition.type === "Compound") {
    return true;
  } else {
    throw new Error(util.format(UNKNOWN_TYPE_ERROR, condition.type));
  }
};

evaluate = function(condition, callback) {
  var error, result;
  try {
    result = recursive_evaluate(condition);
    return callback(null, result);
  } catch (_error) {
    error = _error;
    return callback(error, null);
  }
};

parseAndEvaluate = function(condition, callback) {
  return parser.parse(condition, function(e, r) {
    if (e != null) {
      return callback(e, null);
    } else {
      return evaluate(r, callback);
    }
  });
};

module.exports = {
  evaluate: evaluate,
  parseAndEvaluate: parseAndEvaluate
};
